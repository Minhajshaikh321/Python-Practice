In a **shallow copy**, the behavior regarding how changes to the original and copied lists affect each other can be nuanced, particularly when it comes to modifying nested objects (like lists within lists). Here's a breakdown of why appending to a nested list does not reflect in the shallow copied list, while modifying an element does.

### Understanding Shallow Copy

1. **Copying the Structure**:
   - When you create a shallow copy of a list, a new list is created, but the elements in that new list are references to the same objects found in the original list. 
   - If those elements are mutable objects (like lists), the references point to the same memory locations in both the original and copied lists.

2. **Modifying Nested Objects**:
   - If you modify an element of a nested object that both the original and copied lists refer to, the change is reflected in both lists. This is because they point to the same nested object in memory.

3. **Appending to a Nested List**:
   - If you append a new element to the nested list, it will affect the original list but not the copied list because the original list retains the reference to that nested object. However, the shallow copy creates a separate list that only has the initial reference.
   - The copied list retains a reference to the original nested list but doesn't track changes in the structure of that list (like appends) because the list itself was not copied; only the reference was.

### Example to Illustrate the Behavior

```python
import copy

# Original list with a nested list
original_list = [1, 2, [3, 4]]

# Create a shallow copy
shallow_copied_list = copy.copy(original_list)

# Modify an element in the nested list
shallow_copied_list[2][0] = 'Changed'

# Append a new element to the nested list in the original
original_list[2].append(5)

# Output the original and copied lists
print("Original list:", original_list)          # Output: [1, 2, ['Changed', 4, 5]]
print("Shallow copied list:", shallow_copied_list)  # Output: [1, 2, ['Changed', 4]]
```

### Explanation of the Output

1. **Modification**:
   - When we modify the first element of the nested list in `shallow_copied_list` (`shallow_copied_list[2][0] = 'Changed'`), it reflects in the `original_list` as well because both lists reference the same nested list. Thus, any change to that element will affect both.

2. **Appending**:
   - When we append a new element (`5`) to the nested list in `original_list` using `original_list[2].append(5)`, it modifies the original nested list in memory.
   - Since the shallow copy holds a reference to the original nested list, the new value is added to that same list, making it visible in the original list. However, because we are only appending to the list structure and not changing any of the existing references directly in the copy, the copy does not reflect the new structure that includes `5`.

### Summary

- In a shallow copy, the copied list reflects changes to mutable objects (like lists) when the contents of those objects are modified directly (like changing an element).
- However, structural changes, such as appending or removing elements from a nested list, do not affect the shallow copy because the original list's structure is modified, not the reference itself that the shallow copy holds. The shallow copy retains its initial state at the time of copying, even though it points to the same nested object in memory.